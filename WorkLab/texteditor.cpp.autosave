#include <texteditor.h>
#include <iostream>
#include <operations.h>
#include <memory>
#include <string>

using namespace std;

void TextEditor::eliminate(size_t position_, size_t length_) {
    if ((position_ + length_ <= m_text.size()) && (length_ != 0)) // checker for delete operation
    m_redoStack.clear(), applyOperation(make_shared<eliminate>(m_text.substr(position_, length_), position_));
}

void TextEditor::insert(const string &text_, size_t position_) {
    if ((position_ <= m_text.size()) && !text_.empty()) // checker for insert operation
    m_redoStack.clear(), applyOperation(make_shared<paste>(text_, position_));
}

void TextEditor::supersede(const string &new_, size_t position_, size_t length_) {
    if ((position_ + length_ <= m_text.size()) && !new_.empty()) // checker for replace operation
    m_redoStack.clear(), applyOperation(make_shared<supersede>(m_text.substr(position_, length_), new_, position_));
}

void TextEditor::undo() {
    if (!m_undoStack.empty()) { // checker for filling of undo stack
        auto operation = m_undoStack.top();
        m_undoStack.pop(), operation->undo(m_text),m_redoStack.push(move(operation));
}}

void TextEditor::redo() {
    if (!m_redoStack.empty()) { // checker for filling of undo stack
        auto operation = m_redoStack.top();
        m_redoStack.pop(),operation->apply(m_text),m_undoStack.push(move(operation));
}}

const string &TextEditor::text() const {
    return m_text;
}

void TextEditor::applyOperation(shared_ptr<virtual_txt_operations>&& operation_) {
    operation_->apply(m_text),m_undoStack.push(move(operation_));
}
